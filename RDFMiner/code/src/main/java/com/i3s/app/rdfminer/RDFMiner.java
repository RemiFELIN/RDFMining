/**
 * 
 */
package com.i3s.app.rdfminer;

import com.i3s.app.rdfminer.grammar.evolutionary.CostGP;
import com.i3s.app.rdfminer.launcher.GrammaticalEvolution;
import com.i3s.app.rdfminer.launcher.Evaluator;
import com.i3s.app.rdfminer.mode.Mode;
import com.i3s.app.rdfminer.mode.TypeMode;
import com.i3s.app.rdfminer.output.Results;
import com.i3s.app.rdfminer.output.axiom.AxiomsResultsJSON;
import com.i3s.app.rdfminer.output.axiom.StatJSON;
import com.i3s.app.rdfminer.output.shacl.ShapesResultsJSON;
import com.i3s.app.rdfminer.parameters.CmdLineParameters;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.json.JSONArray;
import org.json.JSONObject;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * The main class of the RDFMiner experimental tool.
 * <p>
 * More information about OWL 2 may be found in the
 * <a href="http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">OWL2
 * Quick Reference, 2nd Edition</a>.
 * </p>
 * 
 * @author Andrea G. B. Tettamanzi & RÃ©mi FELIN
 *
 */
public class RDFMiner {

	private static final Logger logger = Logger.getLogger(RDFMiner.class.getName());

	public static CmdLineParameters parameters = new CmdLineParameters();

	/**
	 * The output file in json
	 */
	public static FileWriter output;
	public static String outputFolder;
	
	// v1.0 evaluate data
	public static JSONArray evaluatedEntities;
	// v1.2 miner data
	public static Results results;
	public static StatJSON stats;
	public static List<JSONObject> content;
	public static int type;
	// v1.4 Mode
	public static Mode mode;

	/**
	 * A table of predicates, used in {@link CostGP}
	 */
	public static String[][] predicateTable;

	/**
	 * The entry point of the RDF Miner application.
	 */
	public static void main(String[] args) throws InterruptedException, ExecutionException, URISyntaxException, IOException {

		// Print the banner of RDF Miner
		System.out.println(Global.BANNER);
		
		// Configure the log4j loggers:
		PropertyConfigurator.configure(Global.LOG4J_PROPERTIES);
		
		// Parse the command-line parameters and options:
		CmdLineParser parser = new CmdLineParser(parameters);

		// if you have a wider console, you could increase the value;
		// here 80 is also the default
		parser.getProperties().withUsageWidth(80);

		try {
			// parse the arguments.
			parser.parseArgument(args);
		} catch (CmdLineException e) {
			// if there's a problem in the command line, you'll get this
			// exception. this will report an error message.
			System.err.println(e.getMessage());
			// print the list of available options
			System.err.println();
			parser.printUsage(System.out);
			System.err.println();
			return;
		}

		if (RDFMiner.parameters.help) {
			// print the list of available options
			System.out.println();
			parser.printUsage(System.out);
			System.out.println();
			return;
		}
		
		logger.info("Number of processors avalaibles: " + Global.NB_THREADS);
		
		if(parameters.timeOut != 0)
			logger.info("Time cap initialized at " + parameters.timeOut + " seconde(s)");
		
		// Load librdfminer_axiom_Axiom.so generated by ./compile_c_code.sh (see /scripts
		// folder)
		System.loadLibrary("rdfminer_entity_axiom_Axiom");

		// Create cache folder if it not already exists
		if(!(new File(Global.CACHE_PATH)).exists()) {
			boolean created = (new File(Global.CACHE_PATH)).mkdir();
			if(created)
				logger.info("Cache folder successfully created");
		}
		
		if (parameters.singleAxiom == null) {
			logger.info("Output folder: " + Global.OUTPUT_PATH + parameters.resultFolder);
			if(!(new File(Global.OUTPUT_PATH + parameters.resultFolder)).exists()) {
				boolean created = (new File(Global.OUTPUT_PATH + parameters.resultFolder)).mkdirs();
				if(created)
					logger.info(Global.OUTPUT_PATH + parameters.resultFolder + " successfully created !");
			}
		}
		RDFMiner.outputFolder = Global.OUTPUT_PATH + parameters.resultFolder;

		// get the mode used ( SHACL Shapes ; OWL 2 Axioms )
		if(parameters.useShaclMode) {
			mode = new Mode(TypeMode.SHACL_SHAPE);
			results = new ShapesResultsJSON();
		} else {
			mode = new Mode(TypeMode.AXIOMS);
			results = new AxiomsResultsJSON();
		}

		// define a SPARQL Endpoint to use if provided
		if (parameters.sparqlEndpoint != null) {
			logger.info("A SPARQL Endpoint is specified !");
			try {
				// Test if the given url is a valid URL or not
				new URL(parameters.sparqlEndpoint);
			} catch (MalformedURLException e) {
				logger.error("The given SPARQL Endpoint is not a valid URL ...");
				System.exit(1);
			}
			Global.SPARQL_ENDPOINT = parameters.sparqlEndpoint;
			logger.info("RDFMiner will use the following SPARQL Endpoint : " + Global.SPARQL_ENDPOINT);

		} else {
			// Define the default SPARQL Endpoint depending of the mode used
			if (RDFMiner.mode.isAxiomMode()) {
				Global.SPARQL_ENDPOINT = Global.VIRTUOSO_DBPEDIA_2015_04_SPARQL_ENDPOINT;
				logger.info("RDFMiner will use the default Virtuoso SPARQL Endpoint : " + Global.SPARQL_ENDPOINT);
				logger.info("This database contains a dump of DBPedia 2015-04 ...");
			} else if (RDFMiner.mode.isShaclMode()) {
				Global.SPARQL_ENDPOINT = Global.CORESE_SPARQL_ENDPOINT;
				logger.info("RDFMiner will use the default Corese SPARQL Endpoint : " + Global.SPARQL_ENDPOINT);
			}
		}

		// define a set of prefixes provided by user (with -prefix option), else use the default prefixes
		if(parameters.prefixesFile != null) {
			File prefixesFile = new File(parameters.prefixesFile);
			if(prefixesFile.exists()) {
				logger.info("RDFMiner will use the given prefixes file : " + prefixesFile.getAbsolutePath());
				try {
					Global.PREFIXES = Files.readString(Path.of(prefixesFile.getAbsolutePath()));
				} catch (IOException e) {
					logger.error("Error when reading the prefix file ...");
					logger.error(e.getMessage());
					System.exit(1);
				}
			} else {
				logger.error("The given prefixes file does not exists ...");
				logger.warn("RDFMiner will use the default prefixes to perform SPARQL queries ...");
			}
		} else {
			logger.info("RDFMiner will use the default prefixes to perform SPARQL queries ...");
		}

		// If parameters.grammaticalEvolution is used, we launch an instance of
		// Grammar-based genetic programming
		if(parameters.grammaticalEvolution) {
			try {
				GrammaticalEvolution.run(parameters);
			} catch (Exception e) {
				e.printStackTrace();
				System.exit(0);
			}
		} else {
			switch (RDFMiner.mode.type) {
				default:
				case TypeMode.AXIOMS:
					Evaluator.runAxiomEvaluation(parameters);
					break;
				case TypeMode.SHACL_SHAPE:
					Evaluator.runShapeEvaluation(parameters);
					break;
			}
		}
	}

}
